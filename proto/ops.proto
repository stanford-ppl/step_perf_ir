syntax = "proto3";

package step_perf_ir;

import "func.proto";
import "datatype.proto";

message Operation {
  string name = 1;
  uint32 id = 2;
  reserved 3 to 9;
  oneof op_type {
    BinaryMap binarymap = 10;
    OffChipLoad off_chip_load = 11;
    OffChipStore off_chip_store = 12;
    RepeatStatic repeat_static = 13;
    Broadcast broadcast = 14;
    FlatPartition flat_partition = 15;
    FlatReassemble flat_reassemble = 16;
    Promote promote = 17;
    BinaryMapAccum binarymap_accum = 18;
    PrinterContext printer_context = 19;
    Bufferize bufferize = 20;
    Streamify streamify = 21;
    DynStreamify dyn_streamify = 22;
    SelectGen select_gen = 23;
    DynOffChipLoad dyn_off_chip_load = 24;
    Flatten flatten = 25;
  }
}

message Bufferize {
  uint32 input_id = 1;
  optional uint32 stream_idx = 2;
  uint32 rank = 3;
  DataType dtype = 4;
}

message Streamify {
  uint32 input_id = 1;
  optional uint32 stream_idx = 2;
  repeated uint32 repeat_factor = 3;
  uint32 rank = 4;
  DataType dtype = 5;
}

message DynStreamify {
  uint32 input_id = 1;
  optional uint32 input_stream_idx = 2;
  uint32 ref_id = 3;
  optional uint32 ref_stream_idx = 4;
  uint32 bufferized_rank = 5;
  uint32 repeat_rank = 6;
  DataType input_dtype = 7;
  DataType ref_dtype = 8;
}

message PrinterContext {
  uint32 input_id = 1;
  optional uint32 stream_idx = 2;
  DataType dtype = 3;
}

message BinaryMap {
  uint32 input_id1 = 1;
  optional uint32 stream_idx1 = 2;
  uint32 input_id2 = 3;
  optional uint32 stream_idx2 = 4;
  ElemtoElemFunc func = 5;
  uint32 compute_bw = 6;
  bool write_back_mu = 7;
  DataType dtype_a = 8;
  DataType dtype_b = 9;
}

message BinaryMapAccum {
  uint32 input_id1 = 1;
  optional uint32 stream_idx1 = 2;
  uint32 input_id2 = 3;
  optional uint32 stream_idx2 = 4;
  ElemtoElemFunc func = 5;
  uint32 tile_row = 6; // required for accumulator initialization
  uint32 tile_col = 7; // required for accumulator initialization
  uint32 rank = 8;
  uint32 compute_bw = 9;
  bool write_back_mu = 10;
  DataType dtype_a = 11;
  DataType dtype_b = 12;
}

message OffChipLoad {
  repeated uint32 tensor_shape_tiled = 1;
  repeated uint32 stride = 2;
  repeated uint32 out_shape_tiled = 3;
  string npy_path = 4;
  uint32 tile_row = 5;
  uint32 tile_col = 6;
  uint32 n_byte = 7;
  DataType dtype = 8;
  uint32 par_dispatch = 9;
}

message DynOffChipLoad {
  uint32 ref_id = 1;
  optional uint32 ref_stream_idx = 2;
  repeated uint32 tensor_shape_tiled = 3;
  repeated uint32 stride = 4;
  repeated uint32 out_shape_tiled = 5;
  string npy_path = 6;
  uint32 tile_row = 7;
  uint32 tile_col = 8;
  uint32 n_byte = 9;
  DataType dtype = 10;
  DataType ref_dtype = 11;
  uint32 par_dispatch = 12;
}

message OffChipStore {
  uint32 input_id = 1;
  optional uint32 stream_idx = 2;
  repeated uint32 tensor_shape_tiled = 3;
  string store_path = 4;
  uint32 tile_row = 5;
  uint32 tile_col = 6;
  DataType dtype = 7;
  uint32 par_dispatch = 8;
}

message RepeatStatic {
  uint32 input_id = 1;
  optional uint32 stream_idx = 2;
  uint32 repeat_factor = 3;
  DataType dtype = 4;
}

message Broadcast {
  uint32 input_id = 1;
  optional uint32 stream_idx = 2;
  uint32 num_consumers = 3;
  DataType dtype = 4;
}

message FlatPartition {
  uint32 input_id = 1;
  uint32 control_id = 2;
  optional uint32 input_stream_idx = 3;
  optional uint32 control_stream_idx = 4;
  uint32 partition_rank = 5;
  uint32 num_consumers = 6;
  DataType input_dtype = 7;
  DataType control_dtype = 8;
  repeated uint32 switch_cycles = 9;
  bool write_back_mu = 10;
}

message FlatReassemble {
  repeated uint32 input_id_list = 1;
  repeated int32 input_stream_idx_list = 2;
  uint32 control_id = 3;
  optional uint32 control_stream_idx = 4;
  uint32 reasssemble_rank = 5;
  DataType input_dtype = 6;
  DataType control_dtype = 7;
  repeated uint32 switch_cycles = 8;
  bool write_back_mu = 9;
}

message SelectGen {
  string npy_path = 1;
  bool is_multihot = 2;
}

message Promote {
  uint32 input_id = 1;
  optional uint32 stream_idx = 2;
  uint32 promote_rank = 3;
  DataType dtype = 4;
}

message Flatten {
  uint32 input_id = 1;
  optional uint32 stream_idx = 2;
  uint32 min_rank = 3;
  uint32 max_rank = 4;
  DataType dtype = 5;
}